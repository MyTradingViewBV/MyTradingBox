/* eslint-disable @typescript-eslint/no-explicit-any */
import { CommonModule } from '@angular/common';
import { Component, OnInit, ViewChild, ElementRef } from '@angular/core';
import { NgChartsModule, BaseChartDirective } from 'ng2-charts';
import {
  Chart as ChartJS,
  TimeScale,
  LinearScale,
  Tooltip,
  Title,
  Legend,
} from 'chart.js';
import {
  CandlestickController,
  CandlestickElement,
} from 'chartjs-chart-financial';
import zoomPlugin from 'chartjs-plugin-zoom';
import 'chartjs-adapter-date-fns';
import { MarketService } from '../../modules/shared/http/market.service';

//
// 📍 Crosshair plugin for better interactivity
//
const crosshairPlugin = {
  id: 'crosshair',
  afterDraw(chart: any): void {
    if (chart.tooltip?._active?.length) {
      const ctx = chart.ctx;
      const x = chart.tooltip._active[0].element.x;
      const y = chart.tooltip._active[0].element.y;

      ctx.save();
      ctx.beginPath();
      // vertical line
      ctx.moveTo(x, chart.chartArea.top);
      ctx.lineTo(x, chart.chartArea.bottom);
      // horizontal line
      ctx.moveTo(chart.chartArea.left, y);
      ctx.lineTo(chart.chartArea.right, y);

      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.strokeStyle = '#555';
      ctx.stroke();
      ctx.restore();
    }
  },
};

//
// 📍 Register Chart.js controllers and plugins
//
ChartJS.register(
  TimeScale,
  LinearScale,
  Tooltip,
  Title,
  Legend,
  CandlestickController,
  CandlestickElement,
  zoomPlugin,
  crosshairPlugin,
);

@Component({
  selector: 'app-chart-simple',
  standalone: true,
  imports: [CommonModule, NgChartsModule],
  templateUrl: 'chart-simple-component.html',
  styleUrls: ['chart-simple-component.scss'],
})
export class ChartSimpleComponent implements OnInit {
  @ViewChild(BaseChartDirective) chart?: BaseChartDirective;
  @ViewChild('chartCanvas', { read: ElementRef }) chartCanvas?: ElementRef;

  chartData: any = { datasets: [] };

  // Touch/gesture tracking
  isInteracting = false;
  gestureType: 'pan' | 'zoom-x' | 'zoom-y' | 'pinch' | null = null;
  private touchStart: { x: number; y: number; time: number } | null = null;
  private mouseStart: { x: number; y: number; time: number } | null = null;
  private lastTouches: TouchList | null = null;
  private initialPinchDistance = 0;
  private fullDataRange: { min: number; max: number } = { min: 0, max: 0 };
  private initialYRange: { min: number; max: number } = { min: 0, max: 0 };

  // TradingView-style zoom constraints
  private readonly MIN_CANDLES_VISIBLE = 10;
  private readonly MAX_CANDLES_VISIBLE = 1000;
  private readonly ZOOM_SENSITIVITY = 0.02;
  private readonly PAN_SENSITIVITY = 1.0;

  //
  // 📊 Chart options with TradingView-style behavior
  //
  chartOptions: any = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: {
      mode: 'nearest',
      intersect: false,
      axis: 'x',
    },
    plugins: {
      legend: { display: false },
      tooltip: {
        enabled: window.innerWidth > 768,
        mode: 'index',
        intersect: false,
      },
      datalabels: { display: false },
      zoom: {
        pan: {
          enabled: false, // We handle this ourselves
        },
        zoom: {
          wheel: { enabled: false }, // We handle this ourselves
          pinch: { enabled: false },
          drag: { enabled: false },
        },
      },
    },
    scales: {
      x: {
        type: 'time',
        time: {
          unit: 'day',
          tooltipFormat: 'MMM dd',
          displayFormats: { day: 'MMM dd' },
        },
        grid: { color: '#2a2a2a', borderColor: '#555' },
        ticks: {
          color: '#aaa',
          autoSkip: true,
          maxTicksLimit: window.innerWidth < 500 ? 4 : 8,
        },
      },
      y: {
        position: 'right',
        beginAtZero: false,
        grid: { color: '#2a2a2a', borderColor: '#555' },
        ticks: {
          color: '#aaa',
          callback: (val: any) => Number(val).toFixed(6),
          maxTicksLimit: 12,
        },
        afterBuildTicks: (axis: any) =>
          (axis.ticks = axis.ticks.filter((_: any, i: number) => i % 2 === 0)),
      },
    },
    layout: { backgroundColor: '#0d1117' },
  };

  constructor(private marketService: MarketService) {}

  ngOnInit(): void {
    this.marketService.getSymbols().subscribe((symbols) => {
      if (symbols?.length) {
        const symbol = symbols[0].SymbolName;
        this.loadCandles(symbol);
      }
    });
  }

  //
  // 📈 Load and setup chart data
  //
  loadCandles(symbol: string): void {
    this.marketService.getCandles(symbol, '1d', 1000).subscribe((candles) => {
      const mapped = candles.map((c) => ({
        x: new Date(c.Time).getTime(),
        o: c.Open,
        h: c.High,
        l: c.Low,
        c: c.Close,
      }));

      if (!mapped.length) return;

      // Store full data range
      this.fullDataRange = {
        min: mapped[0].x,
        max: mapped[mapped.length - 1].x
      };

      // Calculate initial Y range from all data
      const allHighs = mapped.map(c => c.h);
      const allLows = mapped.map(c => c.l);
      this.initialYRange = {
        min: Math.min(...allLows),
        max: Math.max(...allHighs)
      };

      this.chartData = {
        datasets: [
          {
            label: `${symbol} 1D`,
            data: mapped,
            type: 'candlestick',
            borderColor: {
              up: '#26a69a',
              down: '#ef5350',
              unchanged: '#999',
            },
            backgroundColor: {
              up: '#26a69a',
              down: '#ef5350',
              unchanged: '#999',
            },
          },
        ],
      };

      setTimeout(() => {
        this.initializeChart(mapped);
      }, 100);
    });
  }

  private initializeChart(data: any[]): void {
    const chartRef = this.chart?.chart as any;
    if (!chartRef) return;

    // Show last 150 candles initially (TradingView default)
    const initialVisible = Math.min(150, data.length);
    const visibleData = data.slice(-initialVisible);
    
    const xMin = visibleData[0].x;
    const xMax = visibleData[visibleData.length - 1].x;
    
    // Fit Y to visible data with proper buffer
    const visibleHighs = visibleData.map(c => c.h);
    const visibleLows = visibleData.map(c => c.l);
    const yMin = Math.min(...visibleLows);
    const yMax = Math.max(...visibleHighs); // Fixed: was visibleLows
    const yBuffer = (yMax - yMin) * 0.05; // 5% buffer like TradingView

    // Apply initial view
    chartRef.scales.x.options.min = xMin;
    chartRef.scales.x.options.max = xMax;
    chartRef.scales.y.options.min = yMin - yBuffer;
    chartRef.scales.y.options.max = yMax + yBuffer;

    chartRef.update('none');
  }

  //
  // 🎯 Touch Event Handlers - TradingView Style with Axis-Only Single Finger Zoom
  //
  onTouchStart(event: TouchEvent): void {
    event.preventDefault();
    this.isInteracting = true;
    
    if (event.touches.length === 1) {
      const touch = event.touches[0];
      this.touchStart = {
        x: touch.clientX,
        y: touch.clientY,
        time: Date.now()
      };
      this.gestureType = null; // Will be determined by movement direction and location
    } else if (event.touches.length === 2) {
      this.gestureType = 'pinch';
      this.lastTouches = event.touches;
      this.initialPinchDistance = this.getTouchDistance(event.touches);
    }
  }

  onTouchMove(event: TouchEvent): void {
    event.preventDefault();
    
    if (!this.chart?.chart || !this.touchStart) return;
    const chartRef = this.chart.chart as any;
    
    if (event.touches.length === 1) {
      const touch = event.touches[0];
      const deltaX = touch.clientX - this.touchStart.x;
      const deltaY = touch.clientY - this.touchStart.y;
      
      // Check if touch started in axis area (not canvas area)
      if (!this.gestureType && this.isTouchInAxisArea(this.touchStart, chartRef)) {
        const absX = Math.abs(deltaX);
        const absY = Math.abs(deltaY);
        
        if (absX > 15 || absY > 15) { // Minimum threshold before detecting direction
          if (absX > absY) {
            this.gestureType = 'zoom-x'; // Horizontal swipe = zoom X (candle width)
          } else {
            this.gestureType = 'zoom-y'; // Vertical swipe = zoom Y (candle height)
          }
        }
      }

      // Apply gesture-specific action only if in axis area
      if (this.gestureType === 'zoom-x') {
        // Horizontal swipe = adjust candle width (zoom X-axis)
        this.handleHorizontalZoomSwipe(deltaX, chartRef);
        this.touchStart.x = touch.clientX; // Update for continuous gesture
      } else if (this.gestureType === 'zoom-y') {
        // Vertical swipe = adjust candle height (zoom Y-axis)
        this.handleVerticalZoomSwipe(deltaY, chartRef);
        this.touchStart.y = touch.clientY; // Update for continuous gesture
      }
      // Note: No pan functionality for single finger in canvas area - this is intentionally disabled
      
    } else if (event.touches.length === 2 && this.lastTouches && this.gestureType === 'pinch') {
      this.handlePinchZoom(event.touches, chartRef);
    }
  }

  //
  // 🎯 Helper method to detect if touch is in axis area (not canvas area)
  //
  private isTouchInAxisArea(touchPoint: { x: number; y: number }, chartRef: any): boolean {
    if (!chartRef || !chartRef.chartArea) return false;
    
    const canvas = chartRef.canvas;
    const rect = canvas.getBoundingClientRect();
    const chartArea = chartRef.chartArea;
    
    // Convert touch coordinates to canvas coordinates
    const canvasX = touchPoint.x - rect.left;
    const canvasY = touchPoint.y - rect.top;
    
    // Define axis areas (outside the main chart area where candles are drawn)
    const isInXAxisArea = (
      canvasX >= chartArea.left && 
      canvasX <= chartArea.right && 
      (canvasY < chartArea.top || canvasY > chartArea.bottom)
    );
    
    const isInYAxisArea = (
      canvasY >= chartArea.top && 
      canvasY <= chartArea.bottom && 
      (canvasX < chartArea.left || canvasX > chartArea.right)
    );
    
    // Allow zoom gestures only in axis areas
    return isInXAxisArea || isInYAxisArea;
  }

  //
  // 🖱️ Mouse Event Handlers - Updated for Desktop with Axis Detection
  //
  onMouseDown(event: MouseEvent): void {
    if (event.button === 0) {
      this.mouseStart = {
        x: event.clientX,
        y: event.clientY,
        time: Date.now()
      };
      this.isInteracting = true;
      this.gestureType = null; // Will be determined by key modifiers + movement + location
    }
  }

  onMouseMove(event: MouseEvent): void {
    if (!this.mouseStart || !this.chart?.chart) return;

    const chartRef = this.chart.chart as any;
    const deltaX = event.clientX - this.mouseStart.x;
    const deltaY = event.clientY - this.mouseStart.y;

    // Desktop behavior with modifier keys (axis detection not needed for desktop)
    if (event.shiftKey && event.ctrlKey) {
      // Shift + Ctrl = Pan (both axes)
      this.gestureType = 'pan';
      this.handlePan(deltaX, deltaY, chartRef);
      this.mouseStart.x = event.clientX;
      this.mouseStart.y = event.clientY;
    } else if (event.shiftKey) {
      // Shift + drag = horizontal zoom
      this.gestureType = 'zoom-x';
      this.handleHorizontalZoomSwipe(deltaX, chartRef);
      this.mouseStart.x = event.clientX;
    } else if (event.ctrlKey || event.metaKey) {
      // Ctrl + drag = vertical zoom
      this.gestureType = 'zoom-y';
      this.handleVerticalZoomSwipe(deltaY, chartRef);
      this.mouseStart.y = event.clientY;
    } else {
      // Default drag = pan (desktop users expect this)
      this.gestureType = 'pan';
      this.handlePan(deltaX, deltaY, chartRef);
      this.mouseStart.x = event.clientX;
      this.mouseStart.y = event.clientY;
    }
  }

  onMouseUp(event: MouseEvent): void {
    this.isInteracting = false;
    this.gestureType = null;
    this.mouseStart = null;
  }

  onWheel(event: WheelEvent): void {
    event.preventDefault();
    
    if (!this.chart?.chart) return;
    const chartRef = this.chart.chart as any;
    
    // TradingView-style wheel zoom
    const zoomFactor = event.deltaY > 0 ? 1.08 : 0.92; // Reduced for smoother zoom
    
    if (event.shiftKey) {
      // Horizontal zoom with shift
      this.zoomHorizontal(zoomFactor, chartRef);
    } else if (event.ctrlKey || event.metaKey) {
      // Vertical zoom with ctrl/cmd
      this.zoomVertical(zoomFactor, chartRef);
    } else {
      // Default: horizontal zoom (like TradingView)
      this.zoomHorizontal(zoomFactor, chartRef);
    }
  }

  //
  // 🔧 Improved Zoom Methods for Smoother Operation
  //
  private zoomHorizontal(factor: number, chartRef: any): void {
    const xScale = chartRef.scales.x;
    if (!xScale) return;

    const currentRange = xScale.max - xScale.min;
    const center = (xScale.max + xScale.min) / 2;
    
    // Calculate new range with smart limits
    let newRange = currentRange * factor;
    
    // Dynamic constraints based on data
    const data = chartRef.data.datasets[0]?.data || [];
    if (!data.length) return;
    
    const totalRange = this.fullDataRange.max - this.fullDataRange.min;
    const avgCandleWidth = totalRange / data.length;
    
    // More sophisticated range limits
    const minRange = avgCandleWidth * this.MIN_CANDLES_VISIBLE;
    const maxRange = totalRange * 0.98; // Allow slight zoom out beyond data
    
    newRange = Math.max(minRange, Math.min(maxRange, newRange));
    
    // Center-based zoom with bounds checking
    let newMin = center - newRange / 2;
    let newMax = center + newRange / 2;
    
    // Smart boundary constraints
    const dataMin = this.fullDataRange.min - (avgCandleWidth * 2); // Small buffer
    const dataMax = this.fullDataRange.max + (avgCandleWidth * 2);
    
    if (newMin < dataMin) {
      newMin = dataMin;
      newMax = newMin + newRange;
    }
    if (newMax > dataMax) {
      newMax = dataMax;
      newMin = newMax - newRange;
    }

    xScale.options.min = newMin;
    xScale.options.max = newMax;
    
    // Auto-fit Y only for significant zoom changes
    if (Math.abs(factor - 1) > 0.05) {
      this.autoFitYScale(chartRef);
    }
    
    chartRef.update('none');
  }

  private zoomVertical(factor: number, chartRef: any): void {
    const yScale = chartRef.scales.y;
    if (!yScale) return;

    const currentRange = yScale.max - yScale.min;
    const center = (yScale.max + yScale.min) / 2;
    
    // Calculate new range with reasonable limits
    let newRange = currentRange * factor;
    
    // Prevent extreme zoom levels
    const dataRange = this.initialYRange.max - this.initialYRange.min;
    const minRange = dataRange * 0.001; // Very tight zoom allowed
    const maxRange = dataRange * 5; // 5x zoom out max
    
    newRange = Math.max(minRange, Math.min(maxRange, newRange));
    
    yScale.options.min = center - newRange / 2;
    yScale.options.max = center + newRange / 2;
    
    chartRef.update('none');
  }

  private autoFitYScale(chartRef: any): void {
    const xScale = chartRef.scales.x;
    const yScale = chartRef.scales.y;
    const data = chartRef.data.datasets[0]?.data || [];
    
    if (!data.length || !xScale || !yScale) return;

    // Find visible candles
    const visibleCandles = data.filter((candle: any) => 
      candle.x >= xScale.min && candle.x <= xScale.max
    );

    if (!visibleCandles.length) return;

    const highs = visibleCandles.map((c: any) => c.h);
    const lows = visibleCandles.map((c: any) => c.l);
    const maxY = Math.max(...highs);
    const minY = Math.min(...lows);
    
    const buffer = (maxY - minY) * 0.05; // 5% buffer
    
    yScale.options.min = minY - buffer;
    yScale.options.max = maxY + buffer;
  }

  //
  // 🎮 Public Control Methods
  //
  zoomIn(): void {
    if (!this.chart?.chart) return;
    this.zoomHorizontal(0.8, this.chart.chart);
  }

  zoomOut(): void {
    if (!this.chart?.chart) return;
    this.zoomHorizontal(1.25, this.chart.chart);
  }

  resetZoom(): void {
    const chartRef = this.chart?.chart as any;
    if (!chartRef || !this.chartData.datasets[0]?.data.length) return;
    
    this.initializeChart(this.chartData.datasets[0].data);
  }

  fitToData(): void {
    const chartRef = this.chart?.chart as any;
    if (!chartRef) return;
    
    // Fit to all data
    chartRef.scales.x.options.min = this.fullDataRange.min;
    chartRef.scales.x.options.max = this.fullDataRange.max;
    
    const yBuffer = (this.initialYRange.max - this.initialYRange.min) * 0.05;
    chartRef.scales.y.options.min = this.initialYRange.min - yBuffer;
    chartRef.scales.y.options.max = this.initialYRange.max + yBuffer;
    
    chartRef.update('none');
  }

  //
  // 🔁 Double-click to fit visible area
  //
  onChartDblClick(): void {
    if (!this.chart?.chart) return;
    this.autoFitYScale(this.chart.chart as any);
    (this.chart.chart as any).update('none');
  }

  private getTouchDistance(touches: TouchList): number {
    const touch1 = touches[0];
    const touch2 = touches[1];
    return Math.sqrt(
      Math.pow(touch2.clientX - touch1.clientX, 2) +
      Math.pow(touch2.clientY - touch1.clientY, 2)
    );
  }

  //
  // 🎯 Core Interaction Handlers
  //
  private handlePan(deltaX: number, deltaY: number, chartRef: any): void {
    const xScale = chartRef.scales.x;
    const yScale = chartRef.scales.y;
    
    if (!xScale || !yScale) return;

    // Calculate pan amounts based on scale ranges
    const xRange = xScale.max - xScale.min;
    const yRange = yScale.max - yScale.min;
    
    const xPanAmount = (deltaX / chartRef.width) * xRange * this.PAN_SENSITIVITY;
    const yPanAmount = (deltaY / chartRef.height) * yRange * this.PAN_SENSITIVITY;

    // Apply X pan with constraints
    const newXMin = xScale.min - xPanAmount;
    const newXMax = xScale.max - xPanAmount;
    
    if (newXMin >= this.fullDataRange.min && newXMax <= this.fullDataRange.max) {
      xScale.options.min = newXMin;
      xScale.options.max = newXMax;
    }

    // Apply Y pan
    yScale.options.min = yScale.min + yPanAmount;
    yScale.options.max = yScale.max + yPanAmount;

    chartRef.update('none');
  }

  private handlePinchZoom(touches: TouchList, chartRef: any): void {
    if (!this.lastTouches) return;

    const currentDistance = this.getTouchDistance(touches);
    const zoomFactor = currentDistance / this.initialPinchDistance;
    
    // Apply both horizontal and vertical zoom
    this.zoomHorizontal(1 / zoomFactor, chartRef);
    this.zoomVertical(1 / zoomFactor, chartRef);
    
    this.initialPinchDistance = currentDistance;
  }
}
